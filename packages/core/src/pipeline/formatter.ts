import { Session } from "../schema.js";

export interface FormattedSession {
  json: string;
  markdown: string;
  filename: string;
}

/**
 * Format a session into JSON and Markdown strings ready for upload.
 */
export function formatSession(session: Session): FormattedSession {
  const filename = `${session.tool}_${session.id}`;

  return {
    json: formatJson(session),
    markdown: formatMarkdown(session),
    filename,
  };
}

function formatJson(session: Session): string {
  return JSON.stringify(session, null, 2);
}

function formatMarkdown(session: Session): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Agent Chat — ${session.workspace}`);
  lines.push("");

  // Metadata table
  lines.push("| Field | Value |");
  lines.push("|---|---|");
  lines.push(`| Tool | ${session.tool} |`);
  lines.push(`| Session ID | \`${session.id}\` |`);
  if (session.model) lines.push(`| Model | ${session.model} |`);
  if (session.git_branch) lines.push(`| Branch | ${session.git_branch} |`);
  if (session.start_time) lines.push(`| Started | ${formatDate(session.start_time)} |`);
  if (session.end_time) lines.push(`| Ended | ${formatDate(session.end_time)} |`);
  lines.push(`| Captured | ${formatDate(session.captured_at)} |`);
  lines.push("");

  // Stats
  lines.push("## Stats");
  lines.push("");
  lines.push(`- **Messages:** ${session.stats.user_messages} user, ${session.stats.assistant_messages} assistant`);
  lines.push(`- **Tool uses:** ${session.stats.tool_uses}`);
  lines.push(`- **Tokens:** ${session.stats.input_tokens.toLocaleString()} in / ${session.stats.output_tokens.toLocaleString()} out`);
  lines.push("");

  // Files touched
  if (session.metadata.files_touched.length > 0) {
    lines.push("## Files Touched");
    lines.push("");
    for (const f of session.metadata.files_touched) {
      lines.push(`- \`${f}\``);
    }
    lines.push("");
  }

  // Conversation
  lines.push("## Conversation");
  lines.push("");

  for (const msg of session.messages) {
    const roleLabel = msg.role === "user" ? "**User**" : "**Assistant**";
    const timestamp = msg.timestamp ? ` _(${formatDate(msg.timestamp)})_` : "";
    lines.push(`### ${roleLabel}${timestamp}`);
    lines.push("");

    // Thinking block (collapsible)
    if (msg.thinking) {
      lines.push("<details>");
      lines.push("<summary>Extended thinking</summary>");
      lines.push("");
      lines.push(msg.thinking);
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }

    // Tool uses (collapsible) — each tool with a result gets its own nested block
    if (msg.tool_uses && msg.tool_uses.length > 0) {
      lines.push("<details>");
      lines.push(`<summary>Tool uses (${msg.tool_uses.length})</summary>`);
      lines.push("");

      // Tools without results: compact table
      const simple = msg.tool_uses.filter((tu) => !tu.result);
      if (simple.length > 0) {
        lines.push("| Tool | Input |");
        lines.push("|---|---|");
        for (const tu of simple) {
          const escapedInput = tu.input_summary.replace(/\|/g, "\\|");
          lines.push(`| \`${tu.tool}\` | ${escapedInput} |`);
        }
        lines.push("");
      }

      // Tools with results (e.g. Task/subagents): each gets a nested collapsible
      const withResult = msg.tool_uses.filter((tu) => tu.result);
      for (const tu of withResult) {
        lines.push("<details>");
        lines.push(`<summary><code>${tu.tool}</code> — ${tu.input_summary.slice(0, 80)}${tu.input_summary.length > 80 ? "…" : ""}</summary>`);
        lines.push("");
        lines.push(tu.result!);
        lines.push("");
        lines.push("</details>");
        lines.push("");
      }

      lines.push("</details>");
      lines.push("");
    }

    // Message content
    if (msg.content) {
      lines.push(msg.content);
      lines.push("");
    }

    lines.push("---");
    lines.push("");
  }

  // Footer
  lines.push(`_Generated by tokenxtractor v${session.metadata.uploader_version}_`);

  return lines.join("\n");
}

function formatDate(iso: string): string {
  try {
    return new Date(iso).toLocaleString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
      timeZoneName: "short",
    });
  } catch {
    return iso;
  }
}
